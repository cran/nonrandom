% \VignetteIndexEntry{Propensity score}
% \VignetteKeyword{Stratification}
% \VignetteKeyword{Matching}
% \VignetteKeyword{Covariate balance}

\documentclass[11pt,oneside]{article}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{enumerate}
\usepackage{natbib} 
\usepackage{longtable}
\usepackage{Sweave}

\textwidth15cm
\oddsidemargin4mm 
\evensidemargin-4.5mm

\begin{document}

\hyphenation{stra-ti-fi-cation using}


\setlength{\baselineskip}{1.25em}
\setlength{\parskip}{0.5em}
\setlength{\parindent}{0.0em}

\setlength{\skip\footins}{5ex} %% define distance footnote-text

\textheight20cm

\topmargin-10mm
\parindent0em 
\parskip0.5ex plus0.5ex minus0.5ex
\headheight2.5cm 
\headsep0.5cm 

\begin{titlepage}
  \title{Propensity score based data analysis using nonrandom}
  \author{Susanne Stampf} \date{2010-11-02}

  \maketitle
\thispagestyle{empty}

\begin{abstract}
  For some time, propensity score (PS) based methods have been
  frequently applied in the analysis of data from observational
  studies. The PS is the conditional probability of a certain
  treatment or exposure given patient's covariates. PS methods are
  used to eliminate imbalances in baseline covariate distributions
  between treatment or exposure groups and permit to estimate marginal
  effects.
  
  The package \texttt{nonrandom} is a tool for a comprehensive data
  analysis using stratification and matching by PS. Several functions
  are implemented, starting from the selection of the PS model up to
  estimating PS based treatment or exposure effects. Before estimating
  PS, \texttt{relative.effect()} permits to investigate the extent to
  which a covariate is confounding the treatment or exposure effect on
  outcome. This measure may support the decision which covariates
  should be included in the PS model. \texttt{pscore()} estimates the
  PS and provides all information about the model. Stratification and
  matching by PS are implemented in \texttt{ps.makestrata()} and
  \texttt{ps.match()}, respectively. To check covariate balance
  between treatment or exposure groups, \texttt{ps.balance()} applies
  statistical tests or standardized differences to detect covariate
  differences in groups. In addition, \texttt{dist.plot()} provides a
  graphical balance check. Finally, PS based estimators for the
  treatment or exposure effect can be determined by
  \texttt{ps.estimate()}. It also offers a comparison to regression
  based estimates alternatively used.
  
  All functions can be applied separately as well as combined.
  Additionally, it is possible to apply all functions repeatedly to
  decide which analysis strategy is the most suitable one. Print and
  summary functions are available for the most implemented functions.
  
  There are two data examples to illustrate the application of
  \texttt{nonrandom}. In the first data example, quality of life is
  investigated in breast cancer patients in an observational treatment
  study of the German Breast Cancer Study Group (GBSG). The second
  data example deals with lower respiratory tract infections (LRTI) in
  infants and children in the observational study Pri.DE (Pediatric
  Respiratory Infection, Deutschland) in Germany.
\end{abstract}

\end{titlepage}

\pagestyle{headings}

\tableofcontents
\newpage

\section{Introduction}

For some time, PS based methods have been frequently applied in the
analysis of data from observational studies. The PS is defined as
conditional probability of receiving a certain treatment\footnote{In
  the following, we only use the phrase '...  conditional probability
  of receiving a certain treatment', i.e., we concentrate on the
  comparison of outcome in treated and untreated individual. The
  comparison of two treatments, e.g.,new and standard therapy are also
  possible. The PS can be also be the conditional probability of being
  exposed given covariates, respectively, such that the comparison of
  otcome for exposed and unexposed individuals is of interest.} given
covariates \cite{Rose:Rubi:cent:1983}. In general, the PS is unknown
and has to be appropriately estimated, e.g., by fitting a regression
model. The selection of the correct PS model is often the first
obstacle. Lunt et al.\cite{Lunt:Solo:Roth:Glyn:Hyri:Symm:Strm:2009}
proposed a measure estimating the extent to which a covariate is
confounding the treatment effect on outcome. Covariates with a large
extent are potential candidates for the inclusion in the PS model.
This proposal is implemented in the {\tt nonrandom}-package.

In observational studies, covariate distributions differ generally
between treatment groups and PS methods aim to eliminate such
imbalances. There are four PS based methods: stratification, matching,
covariate adjustment and inverse probability weighting by PS. The
first both methods are commonly used and intend to create data
situations as in randomized controlled trials (RCTs) within which
direct comparison of treatment groups are meaningful. Covariate
adjustment by PS is also a favourite approach since it is easily used
as traditional regression modeling including PS in the regression
model in addition to treatment or exposure. The fourth approach,
namely the inverse probability weighting by PS, is rather rarely used
\cite{Rose:mode:1987,Hira:Imbe:esti:2001}. The PS is here used to
weight each individual and it is often applied as weighted regression
\cite{Free:Berk:weig:2008}. Stratification and matching by PS are more
popular methods since they are easy to understand. However, matching
by PS is applied at most in medical research
\cite{Shah:Laup:Hux:Aust:prop:2005,Strm:Josh:Glyn:Avor:Roth:Schn:revi:2006}.

Stratification by PS is used to stratify individuals with similar or
equal PS such that distributions of measured covariates are
sufficiently balanced in treatment groups within each stratum defined
by PS \cite{Rose:Rubi:cent:1983,Rose:Rubi:redu:1984}. It can be
supposed that each stratum mimics a randomized situation within which
distributions of measured covariates are balanced in expectation. If
the assumption of 'SITA' holds, stratum-specific parameters can be
unbiasedly estimated \cite{Rose:Rubi:cent:1983} and those estimates
are then summed up using appropriate weights to estimate the marginal
parameter of interest.

If matching by PS is used, one or more untreated individuals are
matched to one treated individual or vice versa. Individuals within
matched sets have similar PS whereas the similarity is often defined
by a caliper, generally used as one-fifth of the standard deviation of
the logit of the estimated PS \cite{Coch:Rubi:cont:1973}.  Although
matching by PS has been frequently applied
\cite{Shah:Laup:Hux:Aust:prop:2005,Strm:Josh:Glyn:Avor:Roth:Schn:revi:2006},
it has been shown that the dependence structure in the total matched
sample is often not accounted for the estimation of the interesting
parameter
\cite{Rubi:Tham:char:1992}\nocite{Aust:prop:2007}-\cite{Aust:crit:2008}.
Approaches such as generalized linear mixed models and generalized
estimation equations are appropriate to analyze data with correlation
structure
\cite{Neld:Wedd:gene:1972}\nocite{Cox:Snel:anal:1989,Digg:Lian:Zege:anal:1994,Hanl:Nega:Edwa:Forr:stat:2003}-\cite{Dobs:Barn:intr:2008}.\\

In general, PS methods are embedded in the framework of causal
modeling dealing with potential outcomes
\cite{Pear:caus:2000}\nocite{Hern:defi:2003}-\cite{Hern:Robi:esti:2006}.
Consider a pair of random variables ($Y_0$, $Y_1$), where $Y_1$
denotes the outcome of an individual if treated, and $Y_0$ represents
the outcome of the same individual if not treated. The observed
outcome is $Y = ZY_1+(1-Z)Y_0$, and the expected values of
counterfactuals $\mathbf{E}[Y_1]$ and $\mathbf{E}[Y_0]$ can be derived
if an identifying assumption called 'strongly ignorable treatment
assignment' (SITA) holds \cite{Rose:Rubi:cent:1983}. This assumption
states, that, within subgroups defined by PS, the observed outcome of
individuals assigned to treatment $Z = 0$ has the same distribution as
the unobserved outcome of individuals assigned to treatment $Z = 1$,
if the latter had been assigned to treatment $Z = 0$. 

The idea of PS was initiated to estimate marginal linear treatment
effects as $\Delta=\mathbf{E}[Y_1-Y_0]$ \cite{Rose:Rubi:cent:1983}.
By now, the idea has been transferred to estimating the marginal odds
ratio of outcome, i.e., the change in odds of outcome, if everybody
versus nobody were treated
\cite{Graf:Schu:lett:2008}\nocite{Forb:Shor:inve:2008}-\cite{Stam:Graf:Schm:Schu:esti:2010}.
Therefore, marginal probabilities for potential outcomes
$\mathbf{P}[Y_1=0]$ and $\mathbf{P}[Y_1=1]$ have to be estimated which
are used to construct to an appropriate estimator for the marginal
odds ratio defined as $\delta=\frac{p_1/(1-p_1)}{p_0/(1-p_0)}$ with
$p_z=\mathbf{P}[Y_z=1]$, $z=0,1$. In case of stratified data, marginal
probabilities of potential outcomes can be estimated by outcome rates
from PS strata or derived from standard regression results
\cite{Graf:Schu:lett:2008}.\\

In the following, the application of the \texttt{nonrandom} package is
demonstrated step by step introducing all implemented functions. The
usage of the function is illustrated by the exemplary analysis of two
data sets. First, there are data on quality of life in breast cancer
patients in an observational treatment study of the German Breast
Cancer Study Group (GBSG)
\cite{Raus:Saue:Scha:Schu:Olsc:Saue:Seeg:Schm:ther:1995,Senn:Graf:Capu:stra:2007}.
Patients with mastectomy and lumpectomy, respectively, are compared
with each other regarding the quality of life measured as a linear sum
score. The second data example deals with lower respiratory tract
infections (LRTI) in a population of infants and children aged less
than three years in the observational study Pri.DE (Pediatric
Respiratory Infection, Deutschland) in Germany
\cite{Fors:Ihor:Rieg:Step:Fran:Gurt:Bern:Rohw:Werc:Schu:Tsai:Pete:pros:2004}.
Here, the impact of a current infection with the respiratory syncytial
virus (RSV) on the severity of LRTI is investigated
\cite{Stam:Graf:Schm:Schu:esti:2010}.


\section{The estimation of PS}\label{est-ps}

The PS is generally unknown and has to be estimated often done by
fitting an appropriate regression model.  The selection of the PS
model is often a delicate issue
\cite{Drak:effe:1993}-\nocite{Hupp:Loui:prop:2002,Weit:Lapa:Tole:Hume:Mor:prin:2004,Broo:Schn:Roth:Glyn:Avor:Strm:vari:2006}\cite{Rubi:desi:2007}.
A measure describing the extent to which a covariate is confounding
the treatment effect on outcome is proposed by Lunt et
al.~\cite{Lunt:Solo:Roth:Glyn:Hyri:Symm:Strm:2009}. Covariates with a
large impact are potential candidates for the inclusion in the PS
model. This proposal is implemented in function
\texttt{relative.effect()}. If an appropriate PS model is selected,
function \texttt{pscore()} then offers the estimation of PS.

\subsection{Selection of PS model: {\tt relative.effect()}}

An important step is to decide which covariates $X_k$, $k=1,...,K$,
measured at baseline should be included in the PS model. The measure
describing the extent to which a covariate $X_k$ is confounding the
effect of treatment $Z$ on outcome $Y$ is defined as relative effect
(per cent)
\begin{equation*}
  \left\{ (\beta_{z,x_k} - \beta_{z})/\beta_{z} \right\} \times 100
\end{equation*}
with unadjusted treatment effect $\beta_{z}$ and treatment effects
$\beta_{z,x_k}$ adjusted for covariates $X_k$, $k=1,\hdots,K$. If the
outcome is binary, the relative effect (per cent) is defined as
\begin{equation*}
  \left\{ (exp\{\beta_{z,x_k}\} - exp\{\beta_{z}\})/exp\{\beta_{z}\} \right\} \times 100.
\end{equation*}
Therefore, $K+1$ regression models for outcome $Y$, both unadjusted
and adjusted for covariates $X_k$, $k=1,...,K$, are appropriately
fitted using generalized linear regression models with respect to the
measuring scale of outcome (internal use of {\tt glm()}). There are
two options for specification. It is possbile to set separately
outcome, treatment and covariates as strings or numerics using
arguments {\tt resp}, {\tt treat} and {\tt sel}.
\begin{verbatim}
> ## PRI.De data dealing with LRTI 
> load(pride) 
> pride.effect <- relative.effect(data = pride,
+                                 sel = c(2:14),   
+                                 family = "binomial",
+                                 resp = 15,       
+                                 treat = "PCR_RSV") 
\end{verbatim}
Alternatively, one can specify an explicit regression formula using
{\tt formula}:
\begin{verbatim}
> ## STU1 data on quality of life
> load(stu1) 
> stu1.effect <- relative.effect(data = stu1, 
+                                formula = pst~therapie+tgr+age) 
\end{verbatim}
Information about unadjusted and adjusted treatment effects on outcome
as well as corresponding relative effects are available. In the STU1
data example, two covariates are investigated and seem to affect the
treatment effect on outcome.
\begin{verbatim}
> stu1.effect

 Treatment: therapie
 Outcome: pst
 Covariates:  tgr age 

 Unadjusted treatment effect: 1.5894

 Adjusted and relative effects: 

    adj. treatment effect rel. effect
age             0.7880392   50.420198
tgr             1.7004732    6.985956
\end{verbatim}



\subsection{Estimation of PS: {\tt pscore()}}

If an appropriate model for PS is selected, it can be estimated using
function {\tt pscore()}:
\begin{verbatim}
> stu1.ps <- pscore(data = stu1, 
+                    formula = therapie~tgr+age)
>
> pride.ps <- pscore(data = pride,
+                    formula = PCR_RSV~SEX+RSVINF+REGION+
+                                      AGE+ELTATOP+EINZ+EXT,
+                    name.pscore = "ps")
\end{verbatim}
A logistic regression model is fitted using internally the function
{\tt glm()}. It is possible to specify a certain name for the
estimated PS which in turn is used to store the estimated PS in the
data set (argument {\tt name.pscore}, default is {\it pscore}). 
\begin{figure}[h]
  \begin{center}
    %\hspace{-1cm}
    \includegraphics[width=9cm]{pride-psplot.pdf}
    \caption{Density estimation of the estimated PS in PRI.De data using
      ordinary {\tt plot}-function}\label{stu1-plot1}
  \end{center}
\end{figure}
The output object is of class {\it pscore} and contains a list
including comprehensive information about the PS model, e.g., names of
the estimated PS ({\tt \$name.pscore}), treatment ({\tt \$name.treat})
and outcome ({\tt \$name.resp}) as well as the specified formula of
the PS model ({\tt \$formula.pscore}). Furthermore, the complete data
set ({\tt \$data}) extended by the estimated PS, the estimated PS
itself ({\tt \$pscore}) and treatment variable ({\tt \$treat}) are
separately available.

In the new released version of {\tt nonrandom}, it is possible to plot
the estimated density of the estimated PS. Therefore, the ordinary
{\tt plot}-function is used which in turn internally calls the {\tt
  density}-function applied to data per treatment group. This is only
available when the function {\tt pscore} is previously used to
estimate PS (the estimated PS is sourced from {\tt \$pscore}).
\nocite{Rose:obse:1995,Joff:Rose:prop:1999}


\section{PS based methods}

Observational studies frequently exhibit imbalances in covariate
distributions between treatment groups. Stratification and matching by
PS are used to eliminate these imbalances by creating data situation
as in RCTs.

\subsection{Stratification by PS: {\tt ps.makestrata()}}

Stratification by PS groups individuals with similar or identical PS.
Several ways for stratification (argument {\it breaks}) are
implemented in the function {\tt ps.makestrata()} whereas it has been
shown that stratification using quintiles of the PS distribution
yields a ninety per cent bias reduction
\cite{Rose:Rubi:redu:1984,Coch:effe:1968}.

The use of function {\tt ps.makestrata()} depends on the class of the
input object whereas {\it data.frame} and {\it pscore} (if {\tt
  pscore()} is previously used) are permitted. No specification of the
stratification variable (argument {\tt stratified.by}) is needed if
the input object is of class {\it pscore}. The estimated PS stored in
{\tt \$pscore} is automatically sourced. This in contrast to the case
where the input object is of class {\it data frame}. Strata bounds can
be set either by defining a fixed number of strata, using pre-defined
strata bounds or applying appropriate {\tt R} functions.  However, the
default is {\it NULL}, i.e., the stratification variable is factorized
and each factor corresponds to one stratum. This is only meaningful
when the stratification variable has only few values as in case of the
STU1 data where the estimated PS chosen as stratification variable has
only four values.
\begin{verbatim}
> stu1.str4 <- ps.makestrata(object = stu1.ps)
> stu1.str4

 Stratified by:  pscore 

 Strata information: 

    Strata bounds     n     n (per cent)
1           0.601   231            0.358
2           0.709    65            0.101
3           0.824   255            0.395
4           0.883    95            0.147
\end{verbatim}
If an integer is given in argument {\tt breaks}, the number of strata
w.r.t.~the stratification variable is specified:
\begin{verbatim}
> pride.str.b5 <- ps.makestrata(object = pride.ps,
+                               breaks = 5)
> pride.str.b5 

 Stratified by:  ps 

 Strata information: 

    Strata bounds     n     n (per cent)
1  [0.0619,0.168]   175            0.057
2   (0.168,0.275]   796            0.259
3   (0.275,0.382]  1015             0.33
4   (0.382,0.488]   866            0.281
5   (0.488,0.595]   226            0.073
\end{verbatim}
If a numeric vector is given or an appropriate \texttt{R}-function is
used, e.g., {\tt quantile()}, these values explicitly indicate the
stratum bounds. In case of PRI.De data, quintiles from the
distribution of the estimated PS are used for stratification:
\begin{verbatim}
> pride.str5 <- ps.makestrata(object = pride.ps,
+                             breaks = quantile(pride.ps$pscore,  
+                                               seq(0,1,0.2)),
+                             name.stratum.index = "stratum")
> pride.str5

 Stratified by:  ps 

 Strata information: 

    Strata bounds     n     n (per cent)
1  [0.0624,0.236]   616              0.2
2   (0.236,0.306]   615              0.2
3   (0.306,0.369]   616              0.2
4   (0.369,0.431]   615              0.2
5   (0.431,0.594]   616              0.2
\end{verbatim}
The argument {\tt name.stratum.index} specifies the name of the
variable including the generated stratum indices. 

Depending on the class of the input object, {\tt ps.makestrata()}
returns an object of class {\it stratified.pscore} or {\it
  stratified.data.frame}. If the class of the input object is {\it
  pscore}, the output object inherits all values from the input
object. Similar to function {\tt pscore()}, the complete data set
({\tt \$data}) extended by stratum indices labeled by {\tt
  \$name.stratum.index} is available. Furthermore, the name of the
stratification variable ({\tt \$stratified.by}), individual stratum
indices ({\tt \$stratum.index}) generated at least as well as
corresponding stratum intervals ({\tt \$intervals}) are stored in the
output object.

Stratification of data can be done repeatedly, but only information
from the last application is stored separately in the output object.
However, stratum indices from all stratification procedures previously
done are included in the data set stored in the output object.


\subsection{Matching by PS: {\tt ps.match()}}

The most popular PS method to cope with covariate imbalances is
matching by PS. One or more untreated individuals are matched to
treated individuals (or vice versa) according to the estimated PS.
Individuals matched to each other have similar or identical estimated
PS wheres the similarity is determined by a caliper size often defined
with a maximum width of one-fifth of the standard deviation of the
logit of the estimated PS \cite{Coch:Rubi:cont:1973}.

Similar to function {\tt ps.makestrata()}, the use of {\tt ps.match()}
depends both on classes and numbers of input objects.  The classes
{\it data.frame} and {\it pscore} (if {\tt pscore()} is previously
used) are permitted and one or two input objects of class {\it
  data.frame}, respectively, are allowed. No specification of the
matching variable ({\tt matched.by}) is needed if the input object is
of class {\it pscore}.  The estimated PS stored in the input object is
automatically sourced.

In case of one or two data frames as input objects, the matching
variable as well as treatment (argument {\tt treat}) are needed. If
the first data frame only contains data from treated (or untreated)
individuals, a second input object (argument {\tt object.control})
comprising data from untreated (or treated) individuals is necessary.
The indicated matching variable must be the same in both input data
frames. If it differs, the matching variable in the second data frame
(argument {\tt control.matched.by}) must be specified. Independent of
classes and numbers of input objects, the value of treatment
indicating {\it treated} individuals must be given (argument {\tt
  who.treated}, default is 1).

There are further parameters to define the matching procedure: the
matching ratio ({\tt ratio}) indicating how many individuals should be
matched and statements {\tt givenTmatchingC} concerning who should be
matched to whom (treated to untreated individuals (default) or vice
versa). The argument {\tt bestmatch.first} indicating whether matching
partners should be taken randomly from the pool of potential matching
partners ({\tt FALSE}) or those with the most similar estimated PS
({\tt TRUE}, default). Furthermore, a random number can be specified
({\tt setseed}) to make the matching procedure reproducible. The
caliper size can be defined using arguments {\tt caliper} and {\tt x}.
The default setting for the caliper size is one-fifth ({\tt x=2}) of
the standard deviation of the logit of estimated PS ({\tt
  caliper="logit"}). However, it is possible to specify numerics in
argument {\tt caliper} (argument {\tt x} is then disregarded) or to
modify argument {\tt x} in connection with {\tt caliper="logit"}.

As demonstrated in PRI.De data, one untreated individual is matched to
a treated individual ({\tt ratio=1}) and the default caliper size is
used. The matching variable is {\it ps} indicating the estimated PS
stored in the input object {\tt pride.ps}.
\begin{verbatim}
> pride.m1 <- ps.match(object = pride.ps,
+                      ratio = 1, x = 0.2, caliper = "logit",
+                      matched.by = "ps", 
+                      setseed = 38902)
> pride.m1

 Matched by:  ps 

 Matching parameter:
                      
Caliper size:    0.102
Ratio:           1.000
Who is treated?: 1.000

 Matching information:
                           
Untreated to treated?: TRUE
Best match?:           TRUE

 Matching data:
                                        
Number of matched obs:              2062
Number of matched treated obs:      1031
Number of matched untreated obs:    1031
Number of dropped obs:              1016
Number of matching sets:            1031
Number of incomplete matching sets:    0
\end{verbatim}
The matching algorithm for the STU1 data is switched such that two
treated individuals are matched to one untreated individual ({\tt
  givenTmatchingC=FALSE}) since fewer untreated than treated
individuals are available. Furthermore, the caliper size is set to
0.5.
\begin{verbatim}
> stu1.m2 <- ps.match(object  = stu1.ps,
+                     ratio   = 2,
+                     caliper = 0.5,
+                     givenTmatchingC = FALSE,
+                     setseed = 39062)
Argument 'givenTmatchingC'=FALSE: Treated elements were matched to
each untreated element.
> stu1.m2

 Matched by:  pscore 

 Matching parameter:
                    
Caliper size:    0.5
Ratio:           2.0
Who is treated?: 1.0

 Matching information:
                            
Untreated to treated?: FALSE
Best match?:            TRUE

 Matching data:
                                       
Number of matched obs:              501
Number of matched treated obs:      334
Number of matched untreated obs:    167
Number of dropped obs:              145
Number of matching sets:            167
Number of incomplete matching sets:   0
\end{verbatim}
The function {\tt ps.match()} may return three different class types
for the output object(s): {\it matched.pscore}, {\it
  matched.data.frame} or {\it matched.data.frames}. This depends on
class(es) and numbers of input object(s) and on the specification of
argument {\tt combine.output}. This argument is available when there
are two data frames as input objects. The default is {\tt
  combine.output=TRUE} such that the input data frames extended by
matching information are combined for output.

The complete data set and the data set limited to matched individuals
are stored in the output object ({\tt \$data}, {\tt \$data.matched}) .
Both data sets are extended by column(s) including the matching
indices labeled by {\tt name.match.index}. Furthermore, individual
matching indices generated at last ({\tt \$match.index}, {\tt
  \$name.match.index}), the name of the matching variable ({\tt
  \$matched.by}) and several matching parameters ({\tt
  \$match.parameter}) used at last are stored. If there are two input
objects and argument \texttt{combine.output} is set to {\tt FALSE},
values {\tt \$data}, {\tt \$data.matched} and {\tt \$match.index} are
lists of data frames and vectors, respectively, corresponding to input
objects. If the class of the input object is {\it pscore}, the output
object also inherits all values from the input object.



\section{The balance check for covariate distributions}

PS methods are used to eliminate imbalances in covariate distributions
between treatment groups. An important, but often neglected issue is
the balance check of covariate distributions after stratification or
matching by PS. Graphics, statistical tests and standardized
differences can be used to examine covariate distributions
\cite{Aust:asse:2008}\nocite{Hans:esse:2008}-\cite{Aust:rela:2009}.


\subsection{Grahical balance check: {\tt dist.plot()}}

The function {\tt dist.plot()} offers an illustration of covariate
distributions in treatment groups. As before, the use of function {\tt
  dist.plot()} depends on the class of the input object. Therefore,
arguments {\tt treat}, {\tt stratum.index} and {\tt match.index} are
not needed to be specified if the input object results from the
previous application of {\tt ps.makestrata()} or {\tt ps.match()}.
This is in contrast to the case where the input object is of class
{\it data frame}.

If input object is of class {\it stratified.data.frame} or {\it
  stratified.pscore}, covariate distributions are plotted separately
by treatment and strata. If the class of the input object is either
{\it matched.data.frame}, {\it matched.data.frames} or {\it
  matched.pscore}, covariate distributions are illustrated per
treatment group in the matched data. If covariate distributions in
strata or matched data should be compared to distributions in the
original data, i.e, in data before stratification or matching,
argument {\tt compare} has to be set to {\tt TRUE}.
\begin{verbatim}
> ## Figure 2 (left)
> stu1.plot1 <- dist.plot(object = stu1.m2, sel = c("tgr"),
+                         plot.type = 1, 
+                         compare = TRUE,
+                         bar.cex = 1.2, legend.cex=1.2,
+                         label.match = c("original data","matched sample"))
> ## Figure 2 (right)
> stu1.plot2 <- dist.plot(object = stu1.m2, sel = c("age"),
+                         plot.type = 2,
+                         compare = TRUE,
+                         bar.cex = 1.2, legend.cex=1.2, sub.cex=1.2, 
+                         legend.title = "Therapy")
\end{verbatim}
\begin{figure}[h]
  \vspace{-0.75cm}
  \begin{center}
    \includegraphics[width=6.5cm]{stu1-plot1.pdf}
    \includegraphics[width=6.5cm]{stu1-plot2.pdf}
    \caption{Frequencies of categorical covariate 'tgr' indicating tumor
      size (1: $\leq 10$mm, 2: $>$10mm) of patients in STU1 data before
      and after matching; different types of plots in function {\tt
        dist.plot()} are used: {\tt plot.type=1} (left) and {\tt
        plot.type=2} (left)}\label{fig:stu1}
  \end{center}
\end{figure}
There are two different plot types (argument {\tt plot.type}) which
act depending on the measuring scale of covariates. The selected
covariates (argument {\tt sel}) are classified in categorical and
numerical covariates.  Whether a covariate is categorical or not is
decided by argument {\tt cat.level}. The default is 10, i.e.,
covariates with more than 10 different values are considered as
numerical. The default of argument {\tt plot.type} is 1 such that bar
plots are used to show frequencies for categorical and means for
numerical covariates. Covariate distributions are illustrated by means
of histograms if {\tt plot.type=2}. Therefore, argument {\tt
  plot.levels} specifies the number of cutpoints needed to define
histogram classes for numerical covariates. However, this still
depends on the covariate structure to be plotted such that plotted
class number may differ from the specification. If the covariate is
categorical, the number of its categories are used to define
cutpoints.
\begin{verbatim}

> ## Figure 3 (left)
> pride.plot1 <- dist.plot(object = pride.str5, sel = c("AGE"),
+                          plot.type = 1                          
+                          bar.cex = 1.2, sub.cex = 1.3, legend.cex = 1.2)
>
> ## Figure 3 (right)
> pride.plot2 <- dist.plot(object = pride.m1, sel = c("AGE"),
+                          plot.type = 2, compare = TRUE,
+                          legend.title = "RSV infection",
+                          legend.cex = 1.2, label.cex = 1.1, 
+                          sub.cex = 1.2)
\end{verbatim}
There are three further useful arguments. Argument {\tt
  with.legend=TRUE} (default) includes a legend in plots. If {\tt
  plot.type=1}, category labels (if covariate is categorical) or
treatment labels (in case of numerical covariates) are given in the
legend. Therefore, users have to be careful to modify this argument
when categorical and numerical covariates are simultaneously plotted.
If {\tt plot.type} is set to 2, treatment labels are always shown in
the legend independent of covariate type. Arguments {\tt
  label.stratum} and {\tt label.match} permit label modification
within plots. Defaults are {\it Original} and {\it Stratum} and {\it
  Matched}, respectively. Further arguments can be used to modify,
among others, font sizes, labels, colors and plot margins as
illustrated for STU1 data (Figure \ref{fig:stu1}) and PRI.De data
(Figure \ref{fig:pride-plot1}).
\begin{figure}[h]
  \vspace{-0.75cm}
  \begin{center}
    \includegraphics[width=6.5cm]{pride-plot1.pdf} 
    \includegraphics[width=6.5cm]{pride-plot2.pdf}
    \caption{Mean bars and histograms per treatment are illustrated
      for covariate 'AGE'in PRI.De data before and after
      stratification (only right) using argument {\tt plot.type=1}
      (left) and {\tt plot.type=2} (right) in {\tt
        distplot()}}\label{fig:pride-plot1}
  \end{center}
\end{figure}

Numerous values from plotted data using function {\tt dist.plot()} are
stored as lists in the output object, among others, names of
categorical ({\tt \$var.cat}) and numerical covariates ({\tt
  \$var.noncat}) and frequencies ({\tt \$frequency}) or means ({\tt
  \$means}) of covariates separated by treatment. The length and the
manner of list entries depend on the type of selected covariates and
the plot type. For example, the value {\tt frequency} of output object
{\tt stu1.plot1} is a list with length equal to the number of
categorical covariates to be plotted.  The list entries contain
frequencies (scaled to 1) of different values (1 and 2) of covariate
{\tt tgr} per treatment group in original data and matched sample.
\begin{verbatim}
> ## Figure 2 (left); STU1 data matched by PS
> stu1.plot1$var.cat
[1] "tgr"
>
> stu1.plot1$frequency
[[1]]
, , index = original data

   treat
            0         1
  1 0.1796407 0.2713987
  2 0.8203593 0.7286013

, , index = matched sample

   treat
            0         1
  1 0.1796407 0.1676647
  2 0.8203593 0.8323353
\end{verbatim}
If argument {\tt plot.type} is set to 2, cutpoints of histograms for
numerical covariates are also stored in the output object ({\tt
  \$breaks.noncat}). Furthermore, corresponding frequencies in
histogram classes are separately saved for both treatment groups.
\begin{verbatim}
> ## Figure 2 (right); STU1 data matched by PS
> 
> stu1.plot2$var.cat
[1] "age"
> 
> ## Frequencies from categories of covariate 'age' in treatment group 
> ## (Therapy=0) in original data (1st column) and in the matched 
> ## sample (2nd column)
> stu1.plot2$x.s.cat  
[[1]]
   index
      1   2
  1  56  56
  2 111 111
> ## Frequencies from categories of covariate 'age' in treatment group 
> ## (Therapy=1) in original data (1st column) and in the matched 
> ## sample (2nd column)
> stu1.plot2$y.s.cat  
[[1]]
   index
      1   2
  1 294 149
  2 185 185
\end{verbatim}
In case of numerical covariates, the list entries are in turn lists:
\begin{verbatim}
> ## Figure 3 (right); PRI.De data matched by PS
> pride.plot2$var.noncat
[1] "AGE"
>
> ## Frequencies per histogram class in group 'RSV infection = 0' for 
> ## original data (1st list) and in matched sample (2nd list)
> pride.plot2$x.s.noncat
[[1]]
[[1]]$`1`
[1] 383 554 405 310 225 170

[[1]]$`2`
[1] 315 321 178 101  78  38
> 
> ## Frequencies per histogram class in group 'RSV infection = 1' for 
> ## original data (1st list) and in matched sample (2nd list)
> pride.plot2$y.s.noncat
[[1]]
[[1]]$`1`
[1] 393 261 135 123  67  52

[[1]]$`2`
[1] 393 261 135 123  67  52

\end{verbatim}
Using {\tt plot.type=1} in {\tt dist.plot()} for numerical covariates,
means per treatment group are stored in lists of the output object:
\begin{verbatim}
> ## Figure 3 (left); PRI.De data stratified by PS
> pride.plot1$var.noncat
[1] "AGE"
> 
> ## Means in PS strata (columns) in groups of 'RSV infection' 
> ## (1st rows: no infection '0', 2nd row: RSV infection '1')
> pride.plot1$mean  
[[1]]                    
         1        2         3         4         5
0 2.174609 1.482517 0.9733666 0.6686585 0.4156446
1 2.185500 1.563706 1.0035175 0.5804821 0.3117728
\end{verbatim}

In addition to data information to be plotted, treatment ({\tt
  \$treatment}), individual stratum indices ({\tt \$stratum.index}) or
matching indices ({\tt \$match.index}) and selected covariates ({\tt
  \$name.sel}, {\tt \$sel}) are saved in the output object.



\subsection{Statistical tests and standardized differences: {\tt
    ps.balance()} }

Graphical illustration of covariate distributions in treatment groups
may give a first insight in covariate differences between treatment
groups. However, statistical tests decide whether differences between
groups are significant. The function {\tt ps.balance()} permits the
application of statistical tests and results can be used to decide
about covariate balance.  Since there is an ongoing discussion about
the appropriateness of statistical tests for balance decision, since
they depend on the sample size, standardized differences are
recommended, especially in matched data
\cite{Hill:disc:2008}-\nocite{Hans:esse:2008,Stua:deve:2008}\cite{Aust:disc:2008}.\\

Similar to the functions described above, the use of {\tt
  ps.balance()} depends on the class of the input object. If
information about treatment, stratum or matching indices is stored in
the input object, it is not necessary to specify them since they are
automatically sourced from the input object. If the input object is a
{\it data frame}, the corresponding arguments have to be given. By
default, statistical tests (argument {\tt method="classical"}) are
used for balance tests with respect to the measuring scale of selected
covariates. That means, $t$-test and $\chi^2$- test for numerical and
categorical covariates (internal use of {\tt t.test()} and {\tt
  chisq.test()}) are applied whereas the argument {\tt cat.levels}
defines whether a covariate is categorical or numerical (see function
{\tt dist.plot()}). The tests are applied to data both before and
after the balancing procedure (stratification or matching).
\begin{verbatim}
> ## Balance check for stratified PRI.De data using statistical tests 
> pride.str5.bal <- ps.balance(object = pride.str5, 
+                              sel = c(2:8),
+                              method = "classical", 
+                              alpha = 5) 
> pride.str5.bal

 Summary of balance check: 

                  Before: no bal (0) Before: bal (1)
After: no bal (0)                  2               1
After: bal (1)                     1               2

 Covariates not completely tested: 
RSVINF


 Detailed balance check (overall): 

       SEX ETHNO FRUEHG RSVINF HERZ REGION AGE
Before   0     1      1      0    1      0   0
After    1     0      1     NA    1      0   0

 Detailed balance check (per stratum):
 [p-values from tests (significance level: 0.05)]

            SEX ETHNO FRUEHG RSVINF  HERZ REGION   AGE
Before     0.01 0.907  0.413      0 0.518      0     0
------    ----- -----  -----  ----- -----  ----- -----
Stratum 1 0.296 0.632  0.223  0.647 0.766  0.058  0.83
Stratum 2  0.16 0.003   0.98  0.422 0.642  0.133 0.084
Stratum 3 0.798 0.169  0.678  0.757 0.484  0.038 0.429
Stratum 4 0.124 0.212  0.724     NA 0.843  0.542 0.002
Stratum 5  0.96 0.882  0.404     NA 0.523  0.415     0
                                                      
---------  ----  ----   ----   ----  ----   ----  ----
Test      chi^2 chi^2  chi^2  chi^2 chi^2  chi^2     t
\end{verbatim}
At first, a table summarizing balance decisions for all tested
covariates is given. Furthermore, the balance decision for each
selected covariate is shown as well as more detailed information about
test results (p-values) or standardized differences applied before and
after stratification or matching. Covariates, for which tests are not
applicable or standardized differences not computable, are not
contained in the summary balance table, but listed separately.  If the
argmuent {\tt method="stand.diff"}, standardized differences are
calculated before and after the balancing procedure. The table for
detailed balance information then contains standardized differences
instead of p-values.
\begin{verbatim}
> ## Balance check for matched STU1 data using standardized differences
> stu1.m2.bal <- ps.balance(object  = stu1.m2,
+                           sel     = c("tgr","age"),
+                           method  = "stand.diff",
+                           alpha   =  20)
> stu1.m2.bal

 Summary of balance check: 

                      before: no balance (0) before: balance (1)
after: no balance (0)                      1                   0
after: balance (1)                         1                   0

 Covariates not completely tested: ---

 Detailed balance check (overall): 

             tgr age
table.before   0   0
table.after    1   0

 Detailed balance check:
 [Standardized differences (cut point: 20)]

             tgr    age
Before    22.089 58.065
------     -----  -----
After      3.162 22.852
                       
---------   ----   ----
Scale        bin    bin
\end{verbatim}
The information still available by print and summary functions (see
above) is also stored in value {\tt \$bal.test} in the output object.
If standardized differences are calculated (argument {\tt
  method="stand.diff"}), means and standard deviations (SD) per
treatment groups for each covariate are additionally stored (shown
only for treatment labeled by 1):
\begin{verbatim}
> ## Means for covariates 'tgr' and 'age' before (1st row) and after 
> ## matching (2nd row) in treatment group 1
> stu1.balance$bal.test$Means.treat.1
           tgr       age
[1,] 0.7286013 0.3862213
[2,] 0.8323353 0.5538922
>
> ## Standard deviations for covariates 'tgr' and 'age' before (1st row) 
> ## and after matching (2nd row) in treatment group 1
> stu1.balance$bal.test$SDs.treat.1
           tgr       age
[1,] 0.4446813 0.4868823
[2,] 0.3735682 0.4970871
\end{verbatim}

Information about statistical tests applied or covariate types needed
for correct calculation of standardized differences is stored ({\tt
  \$bal.test\$method} in the output object. In addition, the
significance level is available ({\tt \$bal.test\$alpha}). It has to
be interpreted as cutpoint at which the decision about the balance of
a covariate distribution is made if standardized differences are
calculated.\\

The check for balance of covariate distributions entails the knowledge
about the correctness of the PS model. If the PS model is correctly
fitted, at least covariates included in PS model should be
sufficiently balanced after the stratification or matching. Otherwise
re-modeling of the PS model should be considered.


\section{Propensity score based treatment effects: {\tt ps.estimate()}}

The estimation of PS based treatment effect differs in the previous
application of PS method and in the measuring scale of outcome.
Therefore, the following section is separated by PS methods directly
applicable in the {\tt nonrandom} package.

In general, the use of function {\tt ps.estimate()} depends on the
class of the input object. If function {\tt ps.makestrata()} or {\tt
  ps.match()} are previously used, arguments for treatment ({\tt
  treat}), stratum ({\tt stratum.index}) or matching indices ({\tt
  match.index}) are not needed, contrary to the case if the input
object is of class {\it data frame}. In addition to PS based effect
estimates, a regression model can be simultaneously fitted for the
issue of comparison (argument {\tt regr}). The resulting estimates are
those for conditional parameters in regression models. They are
automatically projected to estimates for corresponding marginal
parameters. Furthermore, additional adjustment for still imbalanced
covariates in stratified or matched data can be done (argument {\tt
  adj}).


\subsection{Effect estimator based on stratification by PS}

If stratification is applied in data with numerical outcome, the
marginal treatment effect based on PS is estimated as a weighted sum
of differences of the mean outcomes in treated and untreated
individuals across PS strata. Therefore, two different weighting
schemes are available: on the one hand weights are equal to the
proportion of individuals per stratum ({\tt weights="rr"}) and on the
other hand weights are related to the inverse variance of
stratum-specific treatment effects ({\tt weights="opt"}).
\begin{verbatim}
> ## STU1: Effect estimation of therapy on quality of life ('pst')
> ## based on PS stratification
> stu1.estimate <- ps.estimate(object = stu1.str4,
+                              resp = "pst",  
+                              weights = "opt",
+                              regr = c("tgr", "age")  
> summary(stu1.estimate)

         Summary for effect estimation 


 Treatment/exposure: therapie
 Outcome: pst
 Effect measure: effects 

 Effect estimates:

                effect  SE[effect]  [95%-CI[effect]]
                ------  ----------  ----------------
Crude            1.589       1.261    [-0.883,4.061]
Stratification                                      
 Unadjusted      0.793      1.3068    [-1.768,3.354]
 Adjusted                                        [,]
Regression       0.788      1.2951     [-1.75,3.326]
                                                    

 Stratum-specific parameter estimates:

                     S1     S2    S3     S4
                  -----  ----- -----  -----
Unadjusted effect 3.453 -6.703 1.223 -7.001

 Stratum-specific adjusted parameter estimates:

 Stratum-specific weights:
0.47 0.13 0.34 0.06
\end{verbatim}
The summary function for the output object resulting from {\tt
  ps.estimate()} offers an overview about all estimated effects,
standard errors and confidence intervals. In the example of stratified
STU1 data, no further adjustment in PS strata is specified such that
the respective row in the result table remains empty.\\

In case of stratified data with binary outcome, both the stratified
Mantel-Haenszel (MH) estimator and the estimator based on outcome
rates from PS strata \cite{Graf:Schu:lett:2008} are implemented to
estimate the marginal odds ratio as effect measure. The marginal odds
ratio for outcome describes the change in odds for outcome, if
everybody versus nobody were treated. It is different to the
conditional odds ratio, e.g., estimated by logistic regression (with
the assumption of constant individual odds ratios). The popular
stratified MH estimator stratified by PS can fail to estimate both the
indivdiual, conditional and the marginal odds ratio
\cite{Stam:Graf:Schm:Schu:esti:2010,Gree:inte:1987}. However, the
stratified MH estimator is implemented since often used in the
analysis of stratified data. The approach of outcome rates from PS strata is proposed by Graf et
al.~\cite{Graf:Schu:lett:2008}. PS methods are used to estimate
marginal treatment effects, but only the outcome rates based estimator
fulfills the criteria for an estimator of the marginal odds ratio. It
is defined as an odds ratio of marginal outcome probabilities,
contrary to the stratified MH estimator which is a weighted sum of
stratum-specific odds ratios
\cite{Graf:Schu:lett:2008,Stam:Graf:Schm:Schu:esti:2010}.
\begin{verbatim}
> ## PRI.De: Effect estimation of exposure to RSV infection on the 
> ## severity of LRTI based on data stratified by PS
> pride.estimate <- ps.estimate(object = pride.str5, family = "binomial",
+                               resp = "SEVERE", treat = "PCR_RSV", 
+                               adj = c("REGION", "ETHNO", "AGE"),
+                               regr = SEVERE~PCR_RSV+SEX+ETHNO+FRUEHG + 
+                                      HERZ+ELTATOP+REGION+AGE+KRANKSUM+
+                                      TOBACCO+VOLLSTIL+EXT+EINZ,
+                               weights = "rr")
> summary(pride.estimate)

         Summary for effect estimation 

 Treatment/exposure: PCR_RSV
 Outcome: SEVERE
 Effect measure: odds ratios 

 Effect estimates:
                    or  SE[log[or]]  [95%-CI[or]]
                 -----  -----------  ------------
Crude            1.677       0.0796  [1.435,1.96]
Stratification                                   
  Outcome rates  1.362       0.0805 [1.163,1.595]
  MH             1.419       0.0823 [1.208,1.667]
  Adjusted       1.565       0.2013 [1.055,2.322]
Regression                                       
  Conditional    1.515       0.0904 [1.269,1.809]
  Marginal       1.399       0.0691 [1.222,1.602]
                                                 
 Stratum-specific parameter estimates:

                          S1    S2    S3    S4    S5
                       ----- ----- ----- ----- -----
  outcome rates 'p0'    0.44  0.53  0.55   0.6  0.66
  outcome rates 'p1'    0.48  0.57  0.58  0.71  0.81
  odds ratio            1.16  1.15  1.16  1.67  2.17

 Stratum-specific adjusted parameter estimates:
1.407 1.398 1.245 1.62 2.154
 Stratum-specific weights:
0.2 0.2 0.2 0.2 0.2
\end{verbatim}
There are two options to specify arguments {\tt adj} and {\tt regr}.
On the one hand, they can be specified as typical formulas whereas
treatment has to be the first independent variable. Furthermore,
outcome and treatment must be the same as specified in arguments {\tt
  resp} and {\tt treat}. On the other hand, a vector of strings or
numerics can be given which indicate covariates to be adjusted for in
strata. The used formulas for those fitted regression models are
stored in the output object. Corresponding stratum-specific adjusted
treatment effects are also stored in the output object.

Information stored in the output object is managed as follows. Results
from regression modeling is stored in value {\tt \$lr.estimation}. PS
based results can be found in value {\tt \$ps.estimation}. This value
is in turn divided in {\tt \$ps.estimation\$unadj} and {\tt
  \$ps.estimation\$adj} for unadjusted and adjusted analyses,
respectively. In both values stratum-specific information are stored.
Further values in the output object contain information about outcome
({\tt \$name.resp}, {\tt \$resp}), treatment ({\tt \$name.treat}, {\tt
  \$treat}) and stratum indices ({\tt \$name.stratum.index}, {\tt
  \$stratum.index}). The output object inherits all values from the
input object as well.


\subsection{Effect estimator based on matching by PS}

If matching is applied, the dependency structure of the matched sample
has to be accounted for in the data analysis
\cite{Bres:stat:1980}\nocite{Roth:Gree:Lash:mode:1998}-\cite{Agre:Min:effe:2004}.
Generalized linear mixed models are appropriate and involved in the
{\tt nonrandom} package. Therefore, the function {\tt lmer}
implemented in the \texttt{lme4} package is internally used whereas
random intercepts for matching set are modeled.

The data analysis of matched data can be done in the same way as for
stratified data. The values of the output object in case of matched
data differ slightly from the those based on the analysis of
stratified data. There are naturally no stratum-specific information
and no corresponding weights available, but only an estimated overall
unadjusted and adjusted treatment effects (if argument {\tt adj} is
specified) and corresponding standard errors and confidence intervals.
If the outcome is binary, the standard error is given for the effect
estimate on log-scale.
\begin{verbatim}
> ## STU1: Effect estimation of therapy on quality of life ('pst')
> ## based on PS matching
> 
> stu1.estimate.m2 <- ps.estimate(object = stu1.m2,
+                                 resp = "pst")
> stu1.estimate.m2

 Effect estimation for treatment/exposure on outcome 

 Treatment/exposure: therapie
 Outcome: pst
 Effect measure: difference ('effect')


 Table of effect estimates:

               effect   SE[effect]  [95%-CI[effect]]
                -----  -----------  ----------------
Crude           1.589        1.261    [-0.883,4.061]
Matching                                            
  Unadjusted    0.873       1.3176    [-1.709,3.455]
  Adjusted                                       [,]
Regression                                       [,]
\end{verbatim}
The print function again provides an overview about effect estimates,
corresponding standard errors and confidence intervals. The output
object contains the same information as above when the data analysis
is based on stratified data unless stratum-specific information.
\begin{verbatim}
> ## PRI.De: Effect estimation of exposure to RSV infection on the 
> ## severity of LRTI based on data matched by PS
> 
> pride.estimate.m <- ps.estimate(object = pride.m1,
+                                 resp = "SEVERE",
+                                 family = "binomial")
> pride.estimate.m

 Effect estimation for treatment/exposure on outcome 

 Treatment/exposure: PCR_RSV
 Outcome: SEVERE
 Effect measure: odds ratio ('or')

 Table of effect estimates:

                  or  SE[log[or]]  [95%-CI[or]]
               -----  -----------  ------------
Crude          1.677       0.0796  [1.435,1.96]
Matching                                       
  Unadjusted   1.379       0.0916  [1.152,1.65]
  Adjusted                                  [,]
Regression                                     
  Conditional                               [,]
  Marginal                                  [,]
\end{verbatim}

Altogether, the {\tt nonrandom} package offers PS based ana\-lyses in
an easy way, however, suitable knowledge for adequaete interpretation
of results is still needed. The estimation of treatment effects on
linear and binary outcome is implemented, limited to the situation
considering a binary treatment. It provides the experienced user a set
of functions for an easy and flexible implementation of PS based
analyses. Users who are not familiar with the application of such
methods and the underlying theory are enabled to conduct an adequate
PS based analysis guided by the package.

\bibliographystyle{unsrt}
\bibliography{bib}
\end{document}
